import{_ as a,W as n,X as s,a0 as e}from"./framework-0a321081.js";const c={},i=e(`<h1 id="java继承和多态" tabindex="-1"><a class="header-anchor" href="#java继承和多态" aria-hidden="true">#</a> Java继承和多态</h1><h2 id="继承" tabindex="-1"><a class="header-anchor" href="#继承" aria-hidden="true">#</a> 继承</h2><p>继承是指父与子的关系</p><h3 id="父类" tabindex="-1"><a class="header-anchor" href="#父类" aria-hidden="true">#</a> 父类</h3><p>我们所说的父类，有好几种说法，如超类、基类、派生类、孩子类</p><p>在程序中是使用<code>extends 父类</code>关键字来实现继承关系</p><p>下面这张图可以描述父类和子类的关系</p><p><img src="https://cdn.jsdelivr.net/gh/ismeoh/imgchr//imgs/Java继承和多态-2023-02-25-17-57-56.png" alt="Java继承和多态-2023-02-25-17-57-56"></p><p>我们所说雇员与经理之间的关系是父与子的关系，父类通常只拥有最基础的属性和方法，子类通常拥有一些额外独有的属性和方法，例如经理拥有设置奖金的能力，因此要增加一个独有的方法和属性</p><p>因此，子类要比父类更丰富</p><p>对于子类从父类继承来的方法，子类是可以覆写的，如获取薪资的方法，经理和雇员的薪资明显不同，所以不能使用从父类继承来的方法</p><h2 id="super关键字" tabindex="-1"><a class="header-anchor" href="#super关键字" aria-hidden="true">#</a> super关键字</h2><p>在子类中我们可以使用<code>super</code>关键字来调用父类的方法，如经理的获取薪资虽然已经被覆写，但是我们还是需要使用父类获取薪资的方法，该方法与子类同名，这里可以使用<code>super.父类方法</code>调用</p><p>同理，继承自父类的构造方法也是可以覆写，同理如果需要使用父类的构造方法，可以使用<code>super(参数列表)</code>,通过参数列表来区分调用的哪一个父类构造方法</p><p>综上super有如下用法</p><ul><li>super调用父类方法</li><li>super调用父类构造方法</li></ul><p>代码实现<br> NF</p><h2 id="多态" tabindex="-1"><a class="header-anchor" href="#多态" aria-hidden="true">#</a> 多态</h2><p>多态就是指可以将子类对象赋值给父类类型的对象变量</p><p>如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/ismeoh/imgchr//imgs/Java继承和多态-2023-02-25-18-09-51.png" alt="Java继承和多态-2023-02-25-18-09-51"></p><p>多态注意点<br> 父类无法使用子类独有的方法，如上图</p><h2 id="阻止继承" tabindex="-1"><a class="header-anchor" href="#阻止继承" aria-hidden="true">#</a> 阻止继承</h2><p>我们可以阻止有一个类继承另外一个类，只需在其class之前加一个<code>final</code>关键字即可</p><p>对于方法来讲，如果加上<code>final</code>表示子类可以继承，但是子类不能覆写方法</p><p>对于一个类如果是<code>final类</code>，其方法默认是<code>final</code>，不管你是否显示的声明final；而其数据域（变量）不会自动变成<code>final</code>，只有你用<code>final</code>关键字声明才可以，<code>final</code>修饰的变量表示其值不可变</p><h2 id="协变返回类型" tabindex="-1"><a class="header-anchor" href="#协变返回类型" aria-hidden="true">#</a> 协变返回类型</h2><p>协变返回类型指的是子类中的方法的返回值类型不必严格等同于父类中被重写的方法的返回值类型，而可以是更 &quot;狭窄&quot; 的类型。<br> NF</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Animal&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">DogName</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DogName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">DogName</span> <span class="token punctuation">{</span>
    <span class="token comment">// 一些方法和属性</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，Dog重写了Animal的getName方法，并且返回了一个DogName类型的值，这是一种协变返回类型的使用方式。因为DogName是String类型的子类型，所以可以在子类中返回更具体的类型，而不会导致类型错误。</p><p>需要注意的是，协变返回类型只适用于返回类型，方法参数的类型不能发生变化。另外，在使用协变返回类型时，子类方法的返回类型必须是父类方法返回类型的子类型，否则会导致编译错误。</p><h2 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类" aria-hidden="true">#</a> 抽象类</h2><p>我们所说的抽象类是在class前<code>abstract</code>声明的类，抽象类比普通类更抽象，其作用就是定义一个模板，当然可以定义一些普通的方法，其子类必须实现；也可以定义写抽象方法，不定义其具体实现，但是强制要求子类必须要有其实现，这就是模板的意义即我给你一些模板可以是一些空虚的东西，也可以是一些真实实现的东西，子类必须使用或者实现</p><p>抽象类实际使用时注意以下几点</p><ul><li>抽象类中是可以有普通的方法的</li><li>抽象类中一旦含有<code>abstract</code>定义的抽象方法，那么其类也必须用<code>abstract</code>关键字定义成抽象方法</li><li>抽象类无法实例化,但是可以使用抽象类定义的对象变量来接受其子类的对象，即<code>抽象类 obj = new 子类()</code>类似多态，这里对象变量是指向子类</li><li>抽象子类问题，如果一个抽象类中不全是抽象方法，也就是说既有抽象方法也有普通方法，那么子类必须是使用<code>abstract</code>声明的抽象子类；如果抽象类中全是抽象方法，子类就是普通类</li><li>抽象类中可以含有普通的成员变量，其成员变量类型可以是静态、受保护、私有的、最终的</li><li>抽象类也可以有构造方法</li></ul><h2 id="域保护" tabindex="-1"><a class="header-anchor" href="#域保护" aria-hidden="true">#</a> 域保护</h2><p>我们之前用过<code>private</code>和<code>public</code>关键字，既可以用在数据域也可以用在方法上，其前者表示私有的外部其他类不能访问，前者都可访问。如果只想让其子类访问，可以使用<code>protected</code>关键字</p><p>对于访问修饰符的总结如下</p><ul><li>default 默认，对本包</li><li>public 公用</li><li>private 私有，本类</li><li>protected 受保护，本包或子类，注意这里子类可以不在一个包内</li></ul><h2 id="obeject类" tabindex="-1"><a class="header-anchor" href="#obeject类" aria-hidden="true">#</a> obeject类</h2><p>object类表示所有类的父类，因此适用于之前的写法，即写一个Object类型的变量来接受其子类的方法；在Java中只有基本数据类型不是对象，其他都是</p>`,41),p=[i];function t(l,o){return n(),s("div",null,p)}const r=a(c,[["render",t],["__file","Java继承和多态.html.vue"]]);export{r as default};
