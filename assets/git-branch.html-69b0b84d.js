import{_ as a,X as n,Y as s,a0 as e}from"./framework-5ccfa493.js";const t={},r=e(`<h1 id="git分支管理" tabindex="-1"><a class="header-anchor" href="#git分支管理" aria-hidden="true">#</a> Git分支管理</h1><h2 id="分支原理" tabindex="-1"><a class="header-anchor" href="#分支原理" aria-hidden="true">#</a> 分支原理</h2><p>从c语言指针理解<br> 每一次提交<code>commit</code>都生成一串唯一的哈希值，即地址<br> HEAD、master与dev都是指针变量，即存取哈希值的变量</p><p>开辟分支等同于开辟一个新的指针，这个指针指向不同的地址，即指向不同的哈希值</p><p>不同的指针可以记录不同的地址，因此会产生很多的分支</p><p><img src="https://cdn.jsdelivr.net/gh/ismeoh/imgchr//imgs/20230127204708.png" alt="20230127204708"></p><h2 id="分支合并" tabindex="-1"><a class="header-anchor" href="#分支合并" aria-hidden="true">#</a> 分支合并</h2><p>即对比不同指针指向的内容，进行指针的移动，若有内容冲突解决冲突后再移动指针，没有冲突直接移动指针</p><p><strong>基本流程</strong><br> 1.创建并切换dev分支，在分支dev工作<br> 2.工作完毕后合并分支，即移动master指针到dev<br> 3.切换分支到master，即head指向master<br> 4.删除分支dev<br><img src="https://cdn.jsdelivr.net/gh/ismeoh/imgchr//imgs/20230127205552.png" alt="20230127205552"><br><img src="https://cdn.jsdelivr.net/gh/ismeoh/imgchr//imgs/20230127205626.png" alt="20230127205626"></p><h2 id="分支命令" tabindex="-1"><a class="header-anchor" href="#分支命令" aria-hidden="true">#</a> 分支命令</h2><h3 id="创建命令" tabindex="-1"><a class="header-anchor" href="#创建命令" aria-hidden="true">#</a> 创建命令</h3><p>创建分支并切换<br><code>git checkout -b &lt;分支名&gt;</code></p><p>其中<code>-b</code>表示创建并切换，等同于如下<br><code>git branch &lt;branch-name&gt;</code><br><code>git checkout branch</code></p><h3 id="查看分支" tabindex="-1"><a class="header-anchor" href="#查看分支" aria-hidden="true">#</a> 查看分支</h3><p><code>git branch</code></p><h3 id="切换分支" tabindex="-1"><a class="header-anchor" href="#切换分支" aria-hidden="true">#</a> 切换分支</h3><p><code>git checkout &lt;branch&gt;</code> 创建并切换分支<br><code>git switch -c dev</code><br> 只切换分支<br><code>git switch</code></p><h3 id="合并分支" tabindex="-1"><a class="header-anchor" href="#合并分支" aria-hidden="true">#</a> 合并分支</h3><p><code>git merge &lt;branch&gt;</code>切换分支到当前分支</p><h3 id="删除分支" tabindex="-1"><a class="header-anchor" href="#删除分支" aria-hidden="true">#</a> 删除分支</h3><p><code>git branch -d dev</code><br> 注：该命令只能删除合并过的分支</p><p>如果该分支没有和远程分支合并，该命令不能使用<br> 需要使用<code>-D</code>选项进行强制删除</p><h2 id="冲突合并" tabindex="-1"><a class="header-anchor" href="#冲突合并" aria-hidden="true">#</a> 冲突合并</h2><p>主分支和另外一个分支同时修改文件的内容<br> 切换主分支合并另外一个分支时会发生冲突，需要手动解决冲突</p><p>如下例子，文字描述</p><p>1.main分支创建一个test,输入内容123</p><p>2.创建并切换分支f1<br> f1分支，123下面添加一行456<br> f1分支commit</p><p>3.切换分支main,同样在123下面添加一行789<br> main分支commit</p><p>4.合并分支f1,此时会报错显示冲突</p><p>5.手动解决分支冲突</p><p>6.main再次提交即<code>git commit -m</code>内容</p><p>7查看当前分支合并情况,分支已经合并完成</p><p>8.删除分支f1</p><p>以上命令，都是之前用过的命令</p><p><strong>注意：手动合并分支，不需要再次执行merge指令</strong>，因为已经创建了一个新的提交，如6<br><strong>只有在没有冲突的情况下用merge指令</strong></p><p>如下图</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>图的看法
<span class="token operator">*</span> 表示位置

<span class="token operator">*</span>   <span class="token number">25945</span><span class="token function">c0</span> <span class="token punctuation">(</span><span class="token constant">HEAD</span> <span class="token operator">-</span><span class="token operator">&gt;</span> main<span class="token punctuation">)</span> 冲突解决
<span class="token operator">|</span>\\
<span class="token operator">|</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token function">dc4e6c</span> <span class="token punctuation">(</span>f1<span class="token punctuation">)</span> 这是f1分支的提交<span class="token number">456</span>
<span class="token operator">*</span> <span class="token operator">|</span> 857cabd 这是main分支的第<span class="token number">2</span>次提交<span class="token number">789</span>
<span class="token operator">|</span><span class="token operator">/</span>
<span class="token operator">*</span> 6d04988 main的第<span class="token number">1</span>次提交<span class="token punctuation">,</span>内容<span class="token number">123</span>


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面，可以用 <code>git log --graph --pretty=oneline --abbrev-commit</code>查看<strong>分支合并图</strong></p><p>即如图<br><img src="https://cdn.jsdelivr.net/gh/ismeoh/imgchr//imgs/20230127225940.png" alt="20230127225940"></p><h3 id="快速合并" tabindex="-1"><a class="header-anchor" href="#快速合并" aria-hidden="true">#</a> 快速合并</h3><p><code>fast forward</code>策略<br> 默认策略即使用<code>git merge &lt;branch&gt;</code>不指定任何参数</p><p>使用该策略合并分支，合并完成后，删除该分支后会丢失该分支 ，使用<code>git log</code>查看不到曾经做过分支合并<br> 如下图</p><p><img src="https://cdn.jsdelivr.net/gh/ismeoh/imgchr//imgs/20230128012727.png" alt="20230128012727"></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>合并分支后的图
git log <span class="token operator">--</span>graph <span class="token operator">--</span>pretty<span class="token operator">=</span>oneline <span class="token operator">--</span>abbrev<span class="token operator">-</span>commit
<span class="token operator">*</span> <span class="token function">ea1e740</span> <span class="token punctuation">(</span><span class="token constant">HEAD</span> <span class="token operator">-</span><span class="token operator">&gt;</span> main<span class="token punctuation">,</span> dev<span class="token punctuation">)</span> add7777

git branch <span class="token operator">-</span>d dev 删除dev分支

删除分支后的图
git log <span class="token operator">--</span>graph <span class="token operator">--</span>pretty<span class="token operator">=</span>oneline <span class="token operator">--</span>abbrev<span class="token operator">-</span>commit
<span class="token operator">*</span> <span class="token function">ea1e740</span> <span class="token punctuation">(</span><span class="token constant">HEAD</span> <span class="token operator">-</span><span class="token operator">&gt;</span> main<span class="token punctuation">)</span> add7777

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="no-ff策略" tabindex="-1"><a class="header-anchor" href="#no-ff策略" aria-hidden="true">#</a> no-ff策略</h3><p><code>--no-ff</code>策略<br> 即在分支合并的时候，提交一个新的commit，用来注释这是一个合并，<strong>同时删除分支后</strong>，用<code>git log</code>仍然可以查询到做过分支合并</p><p>如下图</p><p><img src="https://cdn.jsdelivr.net/gh/ismeoh/imgchr//imgs/20230128012829.png" alt="20230128012829"></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>合并分支后的图
<span class="token operator">*</span>   <span class="token number">101</span><span class="token function">a9ff</span> <span class="token punctuation">(</span><span class="token constant">HEAD</span> <span class="token operator">-</span><span class="token operator">&gt;</span> main<span class="token punctuation">)</span> 合并自dev
<span class="token operator">|</span>\\
<span class="token operator">|</span> <span class="token operator">*</span> <span class="token number">7</span><span class="token function">b52306</span> <span class="token punctuation">(</span>dev<span class="token punctuation">)</span> add8888
<span class="token operator">|</span><span class="token operator">/</span>

删除分支
git branch <span class="token operator">-</span>d dev
Deleted branch <span class="token function">dev</span> <span class="token punctuation">(</span>was 7b52306<span class="token punctuation">)</span><span class="token punctuation">.</span>

删除分支后的图
$ git log <span class="token operator">--</span>graph <span class="token operator">--</span>pretty<span class="token operator">=</span>oneline <span class="token operator">--</span>abbrev<span class="token operator">-</span>commit
<span class="token operator">*</span>   <span class="token number">101</span><span class="token function">a9ff</span> <span class="token punctuation">(</span><span class="token constant">HEAD</span> <span class="token operator">-</span><span class="token operator">&gt;</span> main<span class="token punctuation">)</span> 合并自dev
<span class="token operator">|</span>\\
<span class="token operator">|</span> <span class="token operator">*</span> 7b52306 add8888
<span class="token operator">|</span><span class="token operator">/</span>


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>综上，默认策略<code>fast forward</code>和<code>no-ff</code>策略的区别就是，<strong>删除分支后是否能查询到曾经做过分支合并</strong></p><p>从C语言指针理解，<code>fast forward</code>表示，合并即主分支指针指向分支指针所指向的地方，即二者同时指向一个位置，因此删除分支后，看不到分支合并历史<br><code>no-ff</code>合并即创建一个新的内容，其内容是从当前分支指针所指向的地方复制过来的，令主分支和分支指针共同指向它，因此删除分支指针后，原来的提交不会丢失</p><h2 id="现场贮藏" tabindex="-1"><a class="header-anchor" href="#现场贮藏" aria-hidden="true">#</a> 现场贮藏</h2><p>现场贮藏是指存储工作区和stage区的状态</p><p>贮藏区用于保存工作现场，去做另外一件事情，比如修复Bug，需要新建一个Bug分支，但是不能放弃当前工作区和stage区的内容</p><p><code>git stash</code><br> 使用后保存工作区和stage区，并与main同步，即恢复最近一次commit</p><p><strong>恢复工作区</strong><br><code>git stash apply</code>恢复工作区和暂存区 <code>git stash pop</code>恢复同时删除stash</p><p><strong>查看贮藏区</strong><br><code>git stash list</code></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>$ git stash list
stash@<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token operator">:</span> <span class="token constant">WIP</span> on main<span class="token operator">:</span> 56c46e5 ✨ feat<span class="token operator">:</span>

$ git log <span class="token operator">--</span>graph <span class="token operator">--</span>pretty<span class="token operator">=</span>oneline <span class="token operator">--</span>abbrev<span class="token operator">-</span>commit
<span class="token operator">*</span> <span class="token number">56</span><span class="token function">c46e5</span> <span class="token punctuation">(</span><span class="token constant">HEAD</span> <span class="token operator">-</span><span class="token operator">&gt;</span> main<span class="token punctuation">)</span> ✨ feat<span class="token operator">:</span>
<span class="token operator">*</span>   101a9ff 合并自f2

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面可以知道，贮藏区是基于当前分支的最近一次commit基础上来编号的,如<code>stash@{0}</code></p><p><strong>指定恢复某个贮藏</strong><br> 格式<code>git stash apply stash@{&lt;index&gt;}</code><br> 例如恢复编号0的贮藏，<code>git stash apply stash@{0}</code></p><h2 id="特定复制" tabindex="-1"><a class="header-anchor" href="#特定复制" aria-hidden="true">#</a> 特定复制</h2><p>使用场景<br> main分支下开辟dev分支进行开发，出现bug,开辟bug分支修复，合并后删除bug分支<br> 此时，dev分支同样有一样的bug，因此需要修复，此时有以下解决方法</p><p>dev上合并整个main分支<br> 在dev分支上进行相同的修复Bug操作</p><p>以上都不简便，应当进行<strong>特定复制</strong><br> 即将一个特定的提交复制到dev分支</p><p>使用如下命令<br><code>git cherry-pick &lt;hash&gt;</code><br> 例如，bug分支修复bug的commit哈希值是4c805e2,则<code>git cherry-pick 4c805e2</code><br> 注：复制后dev会产生一个新提交，此提交和4c805e2本质一样，只是编号不同</p><h2 id="远程协作" tabindex="-1"><a class="header-anchor" href="#远程协作" aria-hidden="true">#</a> 远程协作</h2><h3 id="查看远程仓库" tabindex="-1"><a class="header-anchor" href="#查看远程仓库" aria-hidden="true">#</a> 查看远程仓库</h3><p><code>git remote [-v]</code><br><code>-v</code>表示详细信息</p><h3 id="推送当前分支到远程分支" tabindex="-1"><a class="header-anchor" href="#推送当前分支到远程分支" aria-hidden="true">#</a> 推送当前分支到远程分支</h3><p><code>git push &lt;远程仓库名&gt; &lt;远程仓库分支&gt;</code><br> 例如<code>git push origin master</code></p><h3 id="指定分支克隆" tabindex="-1"><a class="header-anchor" href="#指定分支克隆" aria-hidden="true">#</a> 指定分支克隆</h3><p>github默认克隆的仓库只有main分支<br> 因此若想把其他分支克隆下来，在main分支用如下命令</p><p><code>git checkout -b &lt;本地分支名&gt; &lt;远程仓库名/分支名&gt;</code><br> 如<code>git checkout -b dev origin/dev</code></p><h3 id="关联远程分支" tabindex="-1"><a class="header-anchor" href="#关联远程分支" aria-hidden="true">#</a> 关联远程分支</h3><p><code>git branch --set-upstream-to=&lt;远程仓库名/分支名&gt; &lt;本地分支名&gt;</code><br> 如<code>git branch --set-upstream-to=origin/dev dev</code></p><h3 id="抓取远程仓库" tabindex="-1"><a class="header-anchor" href="#抓取远程仓库" aria-hidden="true">#</a> 抓取远程仓库</h3><p>用于别人已经在远程仓库进行push,此时你push到远程仓库产生冲突<br> 因此需要使用如下命令，抓取<br><code>git pull</code><br> 抓取完后，手动解决冲突，流程与冲突合并一样</p><h2 id="变基操作" tabindex="-1"><a class="header-anchor" href="#变基操作" aria-hidden="true">#</a> 变基操作</h2><h3 id="基本原理" tabindex="-1"><a class="header-anchor" href="#基本原理" aria-hidden="true">#</a> 基本原理</h3><p>变基是除merge意外另外一种合并分支的方法<br> 所谓变基就是至基于基底元素的分叉，选择一个分叉，将另外一个分叉基于基底做出的变更应用到上面，即所谓的重放</p><p>如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/ismeoh/imgchr//imgs/20230128170137.png" alt="20230128170137"></p><p><img src="https://cdn.jsdelivr.net/gh/ismeoh/imgchr//imgs/20230128170225.png" alt="20230128170225"><br><strong>注：5&#39;表示在4重放5的操作后新生成的5&#39;，下面所有示意图同</strong></p><p>故，变基后提交历史记录里的分叉消失，成了一条直线</p><h3 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h3><p>例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在fork到自己仓库，然后克隆到本地，在自己的分支里进行开发，当开发完成时你需要先将你的代码<strong>变基</strong>到自己的 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要<strong>快进合并</strong>便可。</p><h3 id="命令使用" tabindex="-1"><a class="header-anchor" href="#命令使用" aria-hidden="true">#</a> 命令使用</h3><p>例如要在main分支重放dev</p><p>先切换分支dev<br><code>git checkout &lt;分支main&gt;</code>或使用switch切换</p><p>在分支dev上执行变基命令<br><code>git rebase &lt;将要执行重放的分支,这里是main&gt;</code><br><strong>这里可以理解为，在main分支上重放当前分支dev执行过的操作</strong></p><p><code>--onto</code>选项<br> 用于多分支，指定分支重放<br><code>git rebase --onto &lt;在谁身上重放&gt; &lt;对比分支&gt; &lt;重放分支&gt;</code><br><code>git rebase --onto main server client</code><br> 表示master上重放client与server产生分歧的补丁</p><p>变基前<br><img src="https://cdn.jsdelivr.net/gh/ismeoh/imgchr//imgs/20230128170922.png" alt="20230128170922"><br> 变基client后，6和8消失</p><p><img src="https://cdn.jsdelivr.net/gh/ismeoh/imgchr//imgs/20230128170947.png" alt="20230128170947"></p><p>main上快速合并<br><img src="https://cdn.jsdelivr.net/gh/ismeoh/imgchr//imgs/20230128171018.png" alt="20230128171018"></p><p>继续变基server,7消失<br><img src="https://cdn.jsdelivr.net/gh/ismeoh/imgchr//imgs/20230128171037.png" alt="20230128171037"></p><p>main上快速合并<br><img src="https://cdn.jsdelivr.net/gh/ismeoh/imgchr//imgs/20230128171058.png" alt="20230128171058"></p><p>至此使用变基操作，将client和server全部变基完成，是一条直线，没有分叉<br> 上述快速合并是指<code>git merge &lt;合并分支&gt;</code></p>`,97),p=[r];function o(i,c){return n(),s("div",null,p)}const l=a(t,[["render",o],["__file","git-branch.html.vue"]]);export{l as default};
