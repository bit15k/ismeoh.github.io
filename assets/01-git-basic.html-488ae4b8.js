import{_ as e,V as t,W as r,$ as o}from"./framework-9bf4c1fc.js";const d={},s=o('<h1 id="git基础" tabindex="-1"><a class="header-anchor" href="#git基础" aria-hidden="true">#</a> git基础</h1><h2 id="基本流程" tabindex="-1"><a class="header-anchor" href="#基本流程" aria-hidden="true">#</a> 基本流程</h2><p>以下命令构成了一个基本的工作流程即<br> 包含如下命令</p><p><code>git init</code>初始化git仓库</p><p><code>git add [file or more]</code>添加文件</p><p><code>git commit -m &quot;note&quot;</code>提交版本库</p><p><code>git status</code>查看当前状态</p><h2 id="版本回退" tabindex="-1"><a class="header-anchor" href="#版本回退" aria-hidden="true">#</a> 版本回退</h2><p><code>git diff [file]</code>对比某文件</p><p><code>git log [--pretty=oneline]</code>查看commit快照历史<br> 每次提交commit简称<strong>快照</strong><br> 通过哈希值确定快照的唯一性</p><p><code>git reset --hard 哈希值</code> 回退或指定规定哈希值的快照,通常要与git reflog一同使用<br> 即可以回退以前，也可以再回到现在<br> 其中<code>--hard</code>表示同时回退到工作区和暂存区</p><p>如果回退版本少，可以使用下面简写<br><code>git reset --hard HEAD^</code>^表示回退一次，^^表示回退2次，依次类推</p><p><code>git reflog</code>查看每次执行命令历史，除了add命令不会记录<br> 通常用于查看哈希值，来回退指定版本</p><hr><h2 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h2><p><strong>工作区</strong><br> 即worktree,电脑直接看见的目录</p><p><strong>版本库</strong><br> 主要包含两个<br><strong>stage\\index暂存区</strong> 即add命令添加到的地方<br><strong>master</strong> 即commt添加的地方</p><p>如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/ismeoh/imgchr/imgs/20230126034407.png" alt="20230126034407"></p><p>git的基本工作流程</p><ol><li><code>git init</code>初始化仓库</li><li><code>git add</code>添加到stage</li><li><code>git commit</code>暂存区所有文件添加到master</li></ol><h2 id="管理修改" tabindex="-1"><a class="header-anchor" href="#管理修改" aria-hidden="true">#</a> 管理修改</h2><p>即git的每次修改必须先将文件添加到暂存区，然后再提交到master区</p><p>如下面例子</p><p>① 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit ×</p><p>② 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit √</p><p>①第二次修改没有添加到暂存区，故只提交第一次修改到master</p><p>故git管理的是修改，而不是文件</p><h2 id="撤销修改" tabindex="-1"><a class="header-anchor" href="#撤销修改" aria-hidden="true">#</a> 撤销修改</h2><p>撤销工作区文件包含如下</p><ul><li>修改未提交到stage，未提交master</li><li>修改已经提交到stage,未提交至master</li><li>修改已经提交到stage,已经提交至master</li></ul><p>以下使用<code>git checkout --&lt;file&gt;</code><br> 以下三种情况必须，修改的文件曾经add或commit过，即在stage或master区有快照</p><p><strong>修改未提交到stage，未提交master</strong><br> 那么工作区文件会恢复到和master一样<br><code>git checkout --&lt;file&gt;</code><br> 等同于<code>git restore &lt;file&gt;</code></p><p><strong>修改提交到stage,未提交至master</strong><br> 那么工作区文件会恢复到添加到stage之前的状态<br> 除了使用<code>git checkout --&lt;file&gt;</code>外还可使用<br><code>git reset HEAD &lt;file&gt;</code></p><p>以上，即恢复到最近一次add或commit状态</p><p><strong>修改已经提交到stage,已经提交至master</strong><br> 即版本回退</p><h2 id="删除文件" tabindex="-1"><a class="header-anchor" href="#删除文件" aria-hidden="true">#</a> 删除文件</h2><p>包含如下情况</p><ul><li><p>删除文件，提交stage,提交master<br> 该情况是真删除<br> 以下是误删除的三种情况</p></li><li><p>误删除文件，未提交stage和master</p></li><li><p>误删除文件，提交stage,未提交master，从mater恢复文件到stage,再从stage恢复到master</p></li><li><p>误删除文件，提交stage,提交master，从master恢复文件</p></li></ul><p>以下所有情况必须，修改的文件曾经add或commit过，即在stage或master区有快照</p><p><strong>真删除文件，提交stage,提交master</strong><br> 以下以test示例，说明删除文件的一般操作</p><p>test创建，<br><code>git add test,git commmt test -m &#39;add test&#39;</code><br><code>rm test</code><br><code>git status</code>此时会提示你，工作区删除操作没有被提交<br><code>git rm test</code>,<code>git commit test -m &#39;delete test&#39;</code><br><code>git status</code>此时提交master一并被删除</p><p>注意：git rm和git add是一样的效果</p><p><strong>误删除文件，未提交stage和master，从master恢复</strong><br> 逐步恢复<br><code>git reset HEAD &lt;file&gt;</code>从master恢复到stage<br><code>git restore &lt;file&gt;</code>从stage恢复到工作区</p><p>以上等同于<br><code>git reset --hrad HEAD file</code>,参考版本回退</p><p>等同于 <code>git checkout --file</code></p><p><strong>误删除文件，提交stage,未提交master，从master恢复文件到stage，再从stage恢复到工作区</strong><br><code>git reset HEAD &lt;file&gt;</code>从master恢复到stage<br><code>git restore &lt;file&gt;</code>从stage恢复到工作区<br> 命令<code>git checkout --&lt;file&gt;</code>等同与<code>git reset HEAD</code>该命令已经不太常用，因为它的主要功能是切换分支</p><p><strong>误删除文件，提交stage,提交master，从master恢复文件到stage，再从stage恢复到工作区</strong><br> 该操作与上面一样</p><p>以上三种情况对应修改的三种情况，因为删除也是一种特殊的修改</p><p><code>git restore</code>|<code>git checkout --file</code>|<code>git reset</code><br> 截至到现在，上述三个命令对比</p><p><code>git restore</code>默认是从stage或master恢复至工作区</p><p><code>git reset</code>默认是从master恢复到stage,除非--hard直接同时恢复stage和master</p><p><code>git checkout --file</code>是从暂存区恢复到工作区，该命令在最新版git事实上已经被<code>git reset &amp; git restore</code>取代</p><p>ssh-keygen -t rsa -C “sdtkin1996@outlook.com”</p><h2 id="远程仓库" tabindex="-1"><a class="header-anchor" href="#远程仓库" aria-hidden="true">#</a> 远程仓库</h2><p><strong>生成私钥和公钥</strong><br><code>ssh-keygen -t rsa -C &lt;your email&gt;</code><br> 生成在<code>\\user\\.ssh</code>文件夹下</p><p>rsa是私钥，自己保管<br> pub是公钥</p><p><strong>上传至Github</strong><br> setting-&gt;SSH-&gt;把pub里面内容复制进去</p><p><strong>远程仓库与本地仓库关联</strong><br><code>git remote add &lt;origin-name&gt; git@github.com:&lt;your-name&gt;/&lt;your-repo&gt;.git</code></p><p><strong>向远程仓库推送</strong><br><code>git push -u origin master</code><br> 以上命令表示把当前分支推送到远程仓库的master分支，并且<code>-u</code>命令表示推送并关联远程分支，一般只用一次后续不需要加<code>-u</code></p><p><strong>注：GithUb已经将默认的分支改成了<code>main</code></strong>,因此会多一步将本地分支重命名为main分支，即<code>git branch -M main</code></p><p><strong>删除远程仓库</strong><br> 查看远程仓库<br><code>git remote -v</code><br> 删除远程仓库<br><code>git remote rm &lt;origin&gt;</code></p><p><strong>克隆远程仓库</strong><br> 先创建远程仓库，再从远程库克隆到本地<br><code>git clone git@github.com:&lt;your-name&gt;/&lt;your-repo&gt;.git</code></p><p>以上<code>git</code>开头的协议表示使用<code>ssh</code></p>',64),i=[s];function a(g,c){return t(),r("div",null,i)}const n=e(d,[["render",a],["__file","01-git-basic.html.vue"]]);export{n as default};
