import{_ as e,V as t,W as i,$ as r}from"./framework-9bf4c1fc.js";const s={},d=r(`<h1 id="git基础" tabindex="-1"><a class="header-anchor" href="#git基础" aria-hidden="true">#</a> git基础</h1><h2 id="基本流程" tabindex="-1"><a class="header-anchor" href="#基本流程" aria-hidden="true">#</a> 基本流程</h2><p>以下命令构成了一个基本的工作流程即<br> 包含如下命令</p><p><code>git init</code>初始化git仓库</p><p><code>git add [file or more]</code>添加文件</p><p><code>git commit -m &quot;note&quot;</code>提交版本库</p><p><code>git status</code>查看当前状态</p><h2 id="版本回退" tabindex="-1"><a class="header-anchor" href="#版本回退" aria-hidden="true">#</a> 版本回退</h2><p><code>git diff [file]</code>对比某文件</p><p><code>git log [--pretty=oneline]</code>查看commit快照历史<br> 每次提交commit简称<strong>快照</strong><br> 通过哈希值确定快照的唯一性</p><p><code>git reset --hard 哈希值</code> 回退或指定规定哈希值的快照,通常要与git reflog一同使用<br> 即可以回退以前，也可以再回到现在<br> 其中<code>--hard</code>表示同时回退到工作区和暂存区</p><p>如果回退版本少，可以使用下面简写<br><code>git reset --hard HEAD^</code>^表示回退一次，^^表示回退2次，依次类推</p><p><code>git reflog</code>查看每次执行命令历史，除了add命令不会记录<br> 通常用于查看哈希值，来回退指定版本</p><hr><h2 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h2><p><strong>工作区</strong><br> 即worktree,电脑直接看见的目录</p><p><strong>版本库</strong><br> 主要包含两个<br><strong>stage\\index暂存区</strong> 即add命令添加到的地方<br><strong>master</strong> 即commt添加的地方</p><p>如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/ismeoh/imgchr/imgs/20230126034407.png" alt="20230126034407"></p><p>git的基本工作流程</p><ol><li><code>git init</code>初始化仓库</li><li><code>git add</code>添加到stage</li><li><code>git commit</code>暂存区所有文件添加到master</li></ol><h2 id="管理修改" tabindex="-1"><a class="header-anchor" href="#管理修改" aria-hidden="true">#</a> 管理修改</h2><p>即git的每次修改必须先将文件添加到暂存区，然后再提交到master区</p><p>如下面例子</p><p>① 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit ×</p><p>② 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit √</p><p>①第二次修改没有添加到暂存区，故只提交第一次修改到master</p><p>故git管理的是修改，而不是文件</p><h2 id="撤销修改" tabindex="-1"><a class="header-anchor" href="#撤销修改" aria-hidden="true">#</a> 撤销修改</h2><p>撤销工作区文件包含如下</p><ul><li>修改未提交到stage，未提交master</li><li>修改已经提交到stage,未提交至master</li><li>修改已经提交到stage,已经提交至master</li></ul><p>以下使用<code>git checkout --&lt;file&gt;</code><br> 以下三种情况必须，修改的文件曾经add或commit过，即在stage或master区有快照</p><p><strong>修改未提交到stage，未提交master</strong><br> 那么工作区文件会恢复到和master一样<br><code>git checkout --&lt;file&gt;</code><br> 等同于<code>git restore &lt;file&gt;</code></p><p><strong>修改提交到stage,未提交至master</strong><br> 那么工作区文件会恢复到添加到stage之前的状态<br> 除了使用<code>git checkout --&lt;file&gt;</code>外还可使用<br><code>git reset HEAD &lt;file&gt;</code></p><p>以上，即恢复到最近一次add或commit状态</p><p><strong>修改已经提交到stage,已经提交至master</strong><br> 即版本回退</p><h2 id="删除文件" tabindex="-1"><a class="header-anchor" href="#删除文件" aria-hidden="true">#</a> 删除文件</h2><p>包含如下情况</p><ul><li><p>删除文件，提交stage,提交master<br> 该情况是真删除<br> 以下是误删除的三种情况</p></li><li><p>误删除文件，未提交stage和master</p></li><li><p>误删除文件，提交stage,未提交master，从mater恢复文件到stage,再从stage恢复到master</p></li><li><p>误删除文件，提交stage,提交master，从master恢复文件</p></li></ul><p>以下所有情况必须，修改的文件曾经add或commit过，即在stage或master区有快照</p><p><strong>真删除文件，提交stage,提交master</strong><br> 以下以test示例，说明删除文件的一般操作</p><p>test创建，<br><code>git add test,git commmt test -m &#39;add test&#39;</code><br><code>rm test</code><br><code>git status</code>此时会提示你，工作区删除操作没有被提交<br><code>git rm test</code>,<code>git commit test -m &#39;delete test&#39;</code><br><code>git status</code>此时提交master一并被删除</p><p>注意：git rm和git add是一样的效果</p><p><strong>误删除文件，未提交stage和master，从master恢复</strong><br> 逐步恢复<br><code>git reset HEAD &lt;file&gt;</code>从master恢复到stage<br><code>git restore &lt;file&gt;</code>从stage恢复到工作区</p><p>以上等同于<br><code>git reset --hrad HEAD file</code>,参考版本回退</p><p>等同于 <code>git checkout --file</code></p><p><strong>误删除文件，提交stage,未提交master，从master恢复文件到stage，再从stage恢复到工作区</strong><br><code>git reset HEAD &lt;file&gt;</code>从master恢复到stage<br><code>git restore &lt;file&gt;</code>从stage恢复到工作区<br> 命令<code>git checkout --&lt;file&gt;</code>等同与<code>git reset HEAD</code>该命令已经不太常用，因为它的主要功能是切换分支</p><p><strong>误删除文件，提交stage,提交master，从master恢复文件到stage，再从stage恢复到工作区</strong><br> 该操作与上面一样</p><p>以上三种情况对应修改的三种情况，因为删除也是一种特殊的修改</p><p><code>git restore</code>|<code>git checkout --file</code>|<code>git reset</code><br> 截至到现在，上述三个命令对比</p><p><code>git restore</code>默认是从stage或master恢复至工作区</p><p><code>git reset</code>默认是从master恢复到stage,除非--hard直接同时恢复stage和master</p><p><code>git checkout --file</code>是从暂存区恢复到工作区，该命令在最新版git事实上已经被<code>git reset &amp; git restore</code>取代</p><h2 id="代理配置" tabindex="-1"><a class="header-anchor" href="#代理配置" aria-hidden="true">#</a> 代理配置</h2><p>配置代理</p><p><strong>临时添加与全局添加</strong>命令</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>git config --global http.proxy &#39;socks5://127.0.0.1:socks5端口号&#39;
 
git config --global https.proxy &#39;socks5://127.0.0.1:socks5端口号&#39;
git config --global http.proxy &#39;http://127.0.0.1:http端口号&#39;
 
git config --global https.proxy &#39;https://127.0.0.1:https端口号&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>直接修改用户目录下</strong>，.gitcofig文件添加如下</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>[http]
proxy = socks5://127.0.0.1:socks5端口号
proxy = http://127.0.0.1:http端口号
 
[https]
proxy = socks5://127.0.0.1:socks5端口号
proxy = https://127.0.0.1:http端口号
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重启使配置生效<br><code>git config -l --global</code></p><p>查看当前代理<br><code>git config -l</code></p>`,61),a=[d];function o(c,g){return t(),i("div",null,a)}const l=e(s,[["render",o],["__file","git-basic.html.vue"]]);export{l as default};
